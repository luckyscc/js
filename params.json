{
  "name": "Js",
  "tagline": "js基础",
  "body": "* ### javascript的基础回顾\r\n\r\n#### in关键字\r\n\r\n* 最常用于的是在for in循环中,遍历对象的键\r\n\r\n* 判断属性是否存在于对象中\r\n\r\n* in关键字判断数组的时候是判断索引是否存在,而不是值.\r\n\r\n* indexOf返回值为第一个字母指定的数的索引,如果没有找到返回-1\r\n\r\n#### 值类型和引用类型\r\n\r\n* 值类型:string number boolean undefined,存储的就是数据本身的变量就是值类型的数据\r\n\r\n* 引用类型:引用类型赋值的时候,是将变量中存储的地址复制一份单独存储,但是两个变量共享一个对象.修改其中一个对象另外一个访问的时候也会访问到修改后的对象\r\n\r\n* 值类型做函数的参数:函数内部的变量,也就是形参和实参只是简单的赋值操作,两个数据是单独存储于内存中的,在函数内部修改不会影响到外部的变量\r\n\r\n* 引用类型做函数的参数:还是把实参存储的地址传给形参,在函数内部形参同样也指向该对象所以在函数内部对该对象修该,会影响到外面的变量\r\n\r\n* 如果在函数内部重新创建对象,为该形参赋值,那么两个对象不再有关系,修改其中一个,另外一个不受影响.\r\n\r\n####对像的动态特性\r\n\r\n* 对象刚创建出来为其添加新的属性和方法\r\n\r\n    ```js\r\n\r\n    var obj = {};\r\n\r\n    obj.name = 'zhangsan';\r\n\r\n    ```\r\n\r\n* 使用点语法赋值的时候,如果对象存在该属性,是修改属性,如果不存在该属性,是给对象新增属性并且赋值.如果使用的键不是字符串类型,会隐式的转化为字符串类型\r\n\r\n* 新增属性的方法有\r\n\r\n    * 点语法\r\n\r\n    * 通过[]的形式添加\r\n\r\n####逻辑中断\r\n\r\n* 表达式1||表达式2||表达式3||...:寻找真的表达式找到就返回,找不到返回最后一个\r\n\r\n* 表达式1&&表达式2&&表达式3&&...:寻找假的表达式找到就返回,找不到就返回最后一个\r\n\r\n* &&的优先级比||的高\r\n\r\n####delete关键字\r\n\r\n* delete关键字可以用来删除对象的属性,还有未使用var声明的变量\r\n\r\n* delete关键字有返回值,用来表示删除属性是否成功;如果删除的是不存在的属性,返回值为true,如果删除的属性存在于原型,返回值为true,但是并未删除.\r\n\r\n####函数的定义\r\n\r\n1.函数声明\r\n\r\n```js\r\n\r\nfunction funcName(){}\r\n\r\n```\r\n\r\n2.函数表达式\r\n\r\n```js\r\n\r\nvar funcName1 = function name(){\r\n\r\n    console.log('hello world');\r\n\r\n    }\r\n\r\n```\r\n\r\n3.Function\r\n\r\n```js\r\n\r\nvar funcName2 = new Function();\r\n\r\n```\r\n\r\n####异常处理\r\n\r\n* 异常最大的特征,一旦出现异常,后面的代码就将不再执行,这时候就需要异常处理了\r\n\r\n* 异常捕获语句(try catch)\r\n\r\n```js\r\n\r\ntry catch finally\r\n\r\na();\r\n\r\n```\r\n\r\n* 手动抛出异常\r\n\r\n```js\r\n\r\ntry {\r\n\r\n    a();\r\n\r\n    throw \"代码异常\";    \r\n\r\n}\r\n\r\n    catch(e) {\r\n\r\n    //出现异常后的处理代码\r\n\r\n    }\r\n\r\n```\r\n\r\n* 语法异常 try catch无法捕获\r\n\r\n###面向对象\r\n\r\n###构造函数\r\n\r\n###原型\r\n\r\n####基本概念\r\n\r\n面向对象是一种思维方式,它和面向过程作对比,就是把解决问题关注点,放到解决问题的一系列对象上\r\n\r\n####什么是对象?\r\n\r\n对象就是指一个具体的事物,比如:你们家的狗,你的电脑等等\r\n\r\n* 对象的特征\r\n\r\n    对象的特征就是用来描述对象的相关信息比如一个人对象特征就有:name age gender height\r\n\r\n* 对象的行为\r\n\r\n    比如一个人对象行为就有:吃饭,学习,思考..\r\n\r\n* js中的对象是什么?\r\n\r\n    就是一系列键值对的集合\r\n\r\n####面向对象三大特征\r\n\r\n* 封装\r\n\r\n    封装也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。\r\n\r\n* 继承\r\n\r\n 继承 面向对象编程 (OOP) 语言的一个主要功能就是“继承”。继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。 \r\n\r\n* 多态\r\n\r\n    多态性（polymorphisn）是允许你将父对象设置成为和一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。(js中基本不用)\r\n\r\n####创建对象的方式\r\n\r\n1.对象字面量\r\n\r\n```js\r\n\r\nvar obj = {\r\n\r\n  name:\"jack\",\r\n\r\n  age:18,  \r\n\r\n}    \r\n\r\n```\r\n\r\n2.使用内置构造函数\r\n\r\n```js\r\n\r\nvar obj = new Object();\r\n\r\n```\r\n\r\n3.封装简单的工厂函数\r\n\r\n```js\r\n\r\nfunction createSong(name,age){\r\n\r\nvar o = new Object();\r\n\r\no.name = songName;\r\n\r\no.singer = singerName;\r\n\r\nreturn o;\r\n\r\n}\r\n\r\n```\r\n\r\n4.自定义构造函数\r\n\r\n```js\r\n\r\nfunction Person(){\r\n\r\nthis.name = \"zhangsan\";\r\n\r\nthis.age = 18;\r\n\r\nthis.sayHello = function(){\r\n\r\n    console.log(\"Hello World\");\r\n\r\n    }\r\n\r\n}\r\n\r\nvar p = new Person();//这就是通过构造函数创造出来的对象\r\n\r\n```\r\n\r\n    ####什么是构造函数?\r\n\r\n* 构造函数也是函数,但是通常同来初始化对象并且和new关键字同时出现\r\n\r\n*new是用来创建对象的,构造函数用来初始化对象的(给对象新增成员)\r\n\r\n* 构造函数名首字母要大写\r\n\r\n```js\r\n\r\nfunction Person(){\r\n\r\nthis.name = \"zhangsan\";\r\n\r\nthis.age = 50;\r\n\r\nthis.sayHello = function(){\r\n\r\nconsole.log(\"Hi wo shi zhangsan\");    \r\n\r\n    }\r\n\r\nreturn null;\r\n\r\n}\r\n\r\n```\r\n\r\n####构造函数的返回值\r\n\r\n1.如果不写返回值,默认返回的是新创建出来的对象(一般不会去写return语句)\r\n\r\n2.如果写return语句,return的是空值或者是基本类型或者是null都会默认返回新创建出来的对象\r\n\r\n3.如果返回的是object类型的值将不会返回新创建出来的对象,而是返回return后面的值\r\n\r\n>如果像正常的函数一样使用构造函数,构造函数中的this将不再指向新创建出来的对象(因为根本就没有创建对象),此时构造函数中的this指向的就是window全局对象,当使用this给对象添加成员的时候全部都添加到了window上\r\n\r\n4.js中提供了两个方法来调用其他对象的方法(call,apply)\r\n\r\n####传统的构造函数存在的问题\r\n\r\n如果在构造函数中定义函数,那么每次创建对象的时候都会重新创建该函数,但是函数内部代码完全相同这样就造成了资源浪费,为了处理这个问题我们然所有的对象共用一个方法在构造函数内部定义好该函数,将该函数赋值给构造函数的方法,使用这种方法的好处是this指向的就是调用该方法的对象\r\n\r\n但是使用这种方法存在问题\r\n\r\n1.全局变量增多\r\n\r\n2.代码结构混乱,不易维护\r\n\r\n####什么是原型?\r\n\r\n在构造函数创建出来的时候,系统会自动默认的帮构造函数创建并关联一个神秘的对象,这个对象就是原型\r\n\r\n* 原型默认的是空的对象\r\n\r\n####原型的作用\r\n\r\n* 原型中的属性和方法可以被使用该构造函数创建出来的对象使用\r\n\r\n####如何访问构造函数的原型\r\n\r\n构造函数.prototype\r\n\r\n```js\r\n\r\nfunction Person(name){\r\n\r\nthis.name = name;\r\n\r\n}\r\n\r\nPerson.prototype.exercise = function (){\r\n\r\nconsole.log(\"身体是学习的本钱\");\r\n\r\n}\r\n\r\nvar p = new Person(name);\r\n\r\np.exercise();//可以访问原型的成员\r\n\r\n```\r\n\r\n####实例化\r\n\r\n实例:通过构造函数实例化出来的对象就是构造函数的一个实例\r\n\r\n####原型的使用方法\r\n\r\n1.利用对象的动态特性给原型对象添加成员\r\n\r\n```js\r\n\r\nfunction Person(name){\r\n\r\nthis.name = name;\r\n\r\n}\r\n\r\nPerson.prototype.run = function (){\r\n\r\nconsole.log(\"人会运动\");\r\n\r\n}\r\n\r\n```\r\n\r\n2.直接替换原型对象\r\n\r\n```js\r\n\r\nfunction Person(name){\r\n\r\nthis.name = name;\r\n\r\n}\r\n\r\nPerson.prototype = {\r\n\r\nrun:function (){\r\n\r\nconsole.log(\"人会运动\");\r\n\r\n}\r\n\r\n}\r\n\r\n```\r\n\r\n>但是使用这种直接替换原型对象会出现问题:替换原型之前创建的对象的原型和替换原型之后创建的对象的原型不是同一个\r\n\r\n```js\r\n\r\nfunction Person(){\r\n\r\n}\r\n\r\nPerson.prototype.sayHello = function(){\r\n\r\nconsole.log(\"hello world\");\r\n\r\n}\r\n\r\nvar p = new Person();\r\n\r\nPerson.prototype = {\r\n\r\nmsg:\"hi\"\r\n\r\n};\r\n\r\nvar o = new Person();\r\n\r\n此时对象o没有sayHello方法\r\n\r\n```\r\n\r\n####原型的使用注注意事项\r\n\r\n1.使用对象访问属性的时候,如果在本身内找不到,才回去原型中查找,但是使用点语法进行属性赋值的时候,并不会去原型中进行查找(p.name),使用点语法赋值的时候如果对象中不存在该属性就会为这个对象新增该属性,而不会去修改原型中的属性\r\n\r\n2.如果在原型中的属性是引用类型的属性那么所有的对象共享该属性,并且一个对象修改了该引用类型的成员,其他对象也会受到影响.\r\n\r\n3.一般情况下不会将属性放到原型对象中的,只会放共享的方法进去.\r\n\r\n####__proto__\r\n\r\n* 访问原型的方法\r\n\r\n * 构造函数.prototype\r\n\r\n \r\n\r\n * 对象.__proto__\r\n\r\n* __proto__是一个非标准的属性  \r\n\r\n####constructor\r\n\r\n* 在使用新的对象替换掉默认原型对象之后,原型对象中的constructor属性会变成Object,为了保证合理性在替换原型对象的时候,在新的原型对象中手动添加constructor属性\r\n\r\n####继承的实现方式\r\n\r\n1.混入式继承\r\n\r\n```js\r\n\r\nvar o = {};\r\n\r\nvar obj = {\r\n\r\nname:\"zhangsan\",\r\n\r\nage:18,\r\n\r\nsayHello:function(){\r\n\r\nconsole.log(\"hello world\");\r\n\r\n}\r\n\r\n}\r\n\r\nfor(var k in obj){\r\n\r\no[k] = obj[k];\r\n\r\n}\r\n\r\nconsole.log(o);//这样就实现了继承\r\n\r\n```\r\n\r\n2.原型继承\r\n\r\n>利用原型中的成员可以被和其相关的对象共享这一特性可以实现继承\r\n\r\n* 给原型对象添加成员(通过对象的动态特性)不是严格意义上的继承\r\n\r\n```js\r\n\r\nfunction Person(name,age){\r\n\r\nthis.name = name;\r\n\r\nthis.age = age\r\n\r\n}\r\n\r\nPerson.prototype.sayHello = function(){\r\n\r\nconsole.log(\"hello world\");\r\n\r\n}\r\n\r\nvar p = new Person(\"jack\",19);\r\n\r\np.sayHello();\r\n\r\n```\r\n\r\n* 直接替换原型对象\r\n\r\n```js\r\n\r\nfunction Person(name,age){\r\n\r\nthis.name = name;\r\n\r\nthis.age = age;\r\n\r\nPerson.prototype = {\r\n\r\nsayHello:function(){\r\n\r\n    console.log(\"hello world\");\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\nvar p = new Person(\"rose\",19);\r\n\r\np.sayHello();\r\n\r\n```\r\n\r\n>使用替换原型的方式实现继承的时候,原有原型的成员就会消失.\r\n\r\n* 利用混入式继承给原型对象添加成员\r\n\r\n```js\r\n\r\nfunction Person(name,age){\r\n\r\nthis.name = name;\r\n\r\nthis.age = age;\r\n\r\n}\r\n\r\nPerson.prototype.sayHi = function(){\r\n\r\nconsole.log(\"hey man\");\r\n\r\n}\r\n\r\nvar parent = {\r\n\r\nsayHello:function(){\r\n\r\n    console.log(\"how are you\");\r\n\r\n    }\r\n\r\n}\r\n\r\nfor(var k in parent){\r\n\r\nPerson.prototype[k] = parent[k];\r\n\r\n}\r\n\r\nvar p = new Person(\"jack\",18);\r\n\r\np.sayHello();//结果:how are you\r\n\r\np.sayHi();//结果:hey man,并不会被层叠掉\r\n\r\n```\r\n\r\n3.经典继承\r\n\r\nObject.create(obj);返回值为一个对象,继承自参数中的obj,存在兼容问题\r\n\r\n```js\r\n\r\nfunction create(obj){\r\n\r\n if(Object.create){\r\n\r\n    return Object.create(obj);\r\n\r\n    }else {\r\n\r\n        function F(){\r\n\r\n        F.prototype = obj;\r\n\r\n        return new F();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n```\r\n\r\n####什么是原型链?\r\n\r\n每个构造函数都有原型对象,每个对象都会有构造函数,每个构造函数的原型都是一个对象,这个原型对象也会有构造函数,那么这个原型对象的构造函数也会有原型对象,这样就形成了一个链式的结构,称为原型链\r\n\r\n####原型链结构\r\n\r\n1.当访问一个对象的成员的时候，会现在自身找有没有,如果找到直接使用，\r\n\r\n 2.如果没有找到，则去当前对象的原型对象中去查找，如果找到了直接使用，\r\n\r\n 3.如果没有找到，继续找原型对象的原型对象，如果找到了，直接使用\r\n\r\n 4.如果没有找到，则继续向上查找，直到Object.prototype，如果还是没有，就报错\r\n\r\n####原型继承概念\r\n\r\n通过修改原型链结构实现的继承，就叫做原型继承\r\n\r\n```js\r\n\r\n //动物--->人---->老师---->坏老师\r\n\r\n function Animal(){\r\n\r\n this.gender = \"male\";\r\n\r\n }\r\n\r\n Human.prototype = new Animal();\r\n\r\n Human.prototype.constructor = Human;\r\n\r\n function Human(){\r\n\r\n this.actionWay = \"走路\";\r\n\r\n }\r\n\r\n Teacher.prototype = new Human();\r\n\r\n Teacher.prototype.constructor = Teacher;\r\n\r\n function Teacher(){\r\n\r\n this.skill = \"教书\";\r\n\r\n }\r\n\r\n BadTeacher.prototype = new Teacher();\r\n\r\n BadTeacher.prototype.constructor = BadTeacher;\r\n\r\n function BadTeacher(){\r\n\r\n this.name = \"吕超\";![](/assets/复杂的原型链.png)\r\n\r\n }\r\n\r\n var t = new BadTeacher();\r\n\r\n console.log(t);\r\n\r\n```\r\n\r\n####Object.protottype的成员\r\n\r\n1.constructor:原型对象内的一个属性，指向该原型对象相关联的构造函数\r\n\r\n2.hasOwnPrototype:一个方法，用来判断对象本身（不包含原型）是否拥有某个属性\r\n\r\n3.propertyIsEnumerable:\r\n\r\n* 判断属性是否属于对象本身\r\n\r\n* 判断属性是否可以被遍历\r\n\r\n4.toString和toLocaleString(本地的格式先关)\r\n\r\n5.valueOf\r\n\r\n* 获取当前对象的值\r\n\r\n* 默认的会调用对象的valueOf方法\r\n\r\n* 如果valueOf获取到的值,无法进行运算,就去调用对象的toString方法最终做的就是字符串拼接的工作\r\n\r\n```js\r\n\r\nfunction Person(){}\r\n\r\nvar p = new Person();\r\n\r\nconsolelog(1+p);\r\n\r\n```\r\n\r\n6. ＿＿proto＿＿:原型对象中的属性\r\n\r\n####Function\r\n\r\n* Function这构造函数 可以用来新建函数对象\r\n\r\n* 一个参数都不传的情况 创建的就是一个空的函数,var 函数名 = new Function()\r\n\r\n* 只传一个参数的情况 这个参数就是函数体\r\n\r\n* 传多个参数的情况,最后一个参数为函数体,前面的参数都是该函数的形参名.\r\n\r\n####如何解决使用Funciton创建函数时，代码过长的问题?\r\n\r\n1.可以使用字符串拼接 让代码换行\r\n\r\n2.使用模板的方式，将代码写在模板标签内，获取该标签的内容\r\n\r\n3.使用反引号（`） 引住字符串，那么就可以 换行了\r\n\r\n####arguments对象\r\n\r\n1.一个函数有形参的时候,调用的时候可以不传参数\r\n\r\n2.一个函数没有形参的时候,调用之后,可以传参arguments对象\r\n\r\n3.一个函数不管有没有形参,调用的时候都会把实参的值存入arguments对象\r\n\r\n####eval函数\r\n\r\neval函数可以用来将字符串转换成JavaScript代码并且运行,使用eval来解析JSON格式字符串的时候,会将{}解析为代码块而不是对象字面量\r\n\r\n* 解决办法\r\n\r\n1.在JSON格式的字符串面前拼接上\"var 0 = \"\r\n\r\n2.把JSON格式的字符串使用()就不会将{}解析成代码块,而是表达式\r\n\r\n####静态成员和实例成员\r\n\r\n* 静态成员:是指构造函数的属性和方法\r\n\r\n* 实例成员:是指实例的属性和方法\r\n\r\n>把工具方法,作为静态成员,把跟对象相关的方法作为实例成员\r\n\r\n    原型链\r\n\r\n![](/assets/原型链继承的属性关系.png)\r\n\r\n####Function函数\r\n\r\nFunction函数也可以当做一个构造函数,通过Function new出来函数可以被当做是实例化的对象那么Function这个构造函数也有原型对象\r\n\r\nFunction的原型对象是一个空的函数Function的原型对象的原型对象是Object.prototype\r\n\r\n![](/assets/复杂的原型链.png)\r\n\r\n####递归\r\n\r\n在函数内调用自己,就是递归,没有递归结束条件的递归就是死递归.\r\n\r\n* 自己调用自己\r\n\r\n* 要有结束的条件\r\n\r\n使用递归求1到100的和\r\n\r\n```js\r\n\r\nfunction sum(n){\r\n\r\nif(n==1){\r\n\r\n    return 0;\r\n\r\n    }\r\n\r\nreturn sum(n-1) +n;\r\n\r\n}\r\n\r\nconsole.log(sum(100));//5050\r\n\r\n```\r\n\r\n```js\r\n\r\nfibonacci数列\r\n\r\nfunction fibonacci(n){\r\n\r\n    if(n<=2){\r\n\r\n    return 1;\r\n\r\n}\r\n\r\nreturn fibonacci(n-1) + fibonacci(n-2);\r\n\r\n}\r\n\r\nconsole.log(fibonacci(10));\r\n\r\n```\r\n\r\n####作用域\r\n\r\n域,表示的是一个范围,作用域,就是作用范围.\r\n\r\n作用域说明的是一个变量可以在什么地方被使用,什么地方不能被使用.\r\n\r\n####块级作用域\r\n\r\njs中没有块级作用域\r\n\r\n####词法作用域\r\n\r\n就是在代码写好的时候的那一刻,变量的作用域已经确定了,这种作用域就是叫词法作用域,和词法作用域相对的就是叫动态作用域,词法作用域不是动态作用域.\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}